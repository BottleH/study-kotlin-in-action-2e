# PART_13 DSL 구축
<br><br>
<hr>
<hr>

## 다루는 내용

>- 도메인 특화 언어 만들기 
>- 수신 객체 지정 람다 사용 
>- invoke 관례 사용 
>- 기존 코틀린 DSL 예제

<hr> 
<br><br>

### 13.1 API에서 DSL로
- DSL(Domain-Specific Language)은 특정 도메인에 맞춘 선언적이고 가독성 높은 코드 작성법
- 내부 DSL은 코틀린 문법 안에서 자연스럽게 구성되고 기존 코드와 매끄럽게 통합됨

### 13.1.1 도메인 특화 언어
- DSL은 API보다 표현력이 뛰어나고 읽기 쉽다

### 13.1.2 내부 DSL은 프로그램 나머지 부분과 자연스럽게 통합된다
- 코틀린 DSL은 별도의 문법 없이 기존 코드와 조화롭게 사용 가능

### 13.1.3 DSL의 구조
- 중첩된 계층 구조로 표현하는 경우가 많으며, 트리 형태 데이터를 자연스럽게 다룸 
- 각 DSL 요소는 별도 클래스와 빌더 함수를 통해 하위 요소를 등록

```html
html {
    body {
        p("Hello")
    }
}
```


### 13.1.4 내부 DSL로 HTML 만들기
- 코틀린 수신 객체 람다, 확장 함수로 HTML 구조를 선언적으로 표현 가능

### 13.2 구조화된 API 구축: DSL에서 수신 객체 지정 람다 사용
### 13.2.1 수신 객체 지정 람다와 확장 함수 타입
- 함수 타입 T.() -> Unit은 람다 안에서 수신 객체 멤버를 직접 호출 가능
- 확장 함수 타입과 람다 수신자가 DSL 문법의 핵심

### 13.2.2 수신 객체 지정 람다를 HTML 빌더 안에서 사용
- HTML 빌더 DSL에서 각 태그 블록을 수신 객체 지정 람다로 구현해 중첩 구조 표현
- 예: fun body(init: Body.() -> Unit)

### 13.2.3 코틀린 빌더: 추상화와 재사용을 가능하게 해준다
- 빌더 패턴과 수신 객체 지정 람다 결합으로 유연하고 재사용 가능한 DSL 구축 가능
- 공통 함수로 중복 제거, 다양한 DSL 구성 가능

### 13.3 invoke 관례를 사용해 더 유연하게 블록 내포시키기
### 13.3.1 invoke 관례를 사용해 더 유연하게 블록 내포시키기
- operator fun invoke() 정의로 객체를 함수처럼 호출 가능해져, DSL에서 자연스러운 블록 중첩 지원
- 예: 태그 클래스에 invoke 연산자 추가

### 13.3.2 DSL의 invoke 관례: 그레이들 의존관계 선언
- Gradle DSL도 invoke 관례를 활용해 의존관계 선언을 간결하고 읽기 쉽게 표현
dependencies {
  implementation("org.jetbrains.kotlin:kotlin-stdlib")
}

### 13.4 실전 코틀린 DSL
### 13.4.1 중위 호출 연쇄시키기: 테스트 프레임워크의 should 함수
- 테스트 DSL에서 infix 함수로 중위 호출 연쇄 가능 
- 예: "result" shouldBe "expected"

### 13.4.2 원시 타입에 대한 확장 함수 정의하기: 날짜 처리
- 숫자 타입에 확장 프로퍼티, 함수 정의해 날짜 계산 DSL 구현
- 예: val yesterday = 1.days.ago

### 13.4.3 멤버 확장 함수: SQL을 위한 내부 DSL
- SQL 쿼리 DSL에서 멤버 확장 함수로 내부 DSL 작성
- 멤버 확장 함수는 수신 객체와 확장 함수 수신 객체가 결합된 형태로, 복잡한 문법 구현에 유용