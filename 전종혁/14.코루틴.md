# PART_14 코루틴
<br><br>
<hr>

## 다루는 내용
>- 동시성과 병렬성의 개념 
>- 코틀린에서 동시성 연산을 만드는 빌딩 블록인 일시 중단 함수 
>- 코틀린에서 코루틴을 활용해 동시성 프로그래밍에 접근하는 방법

### 14.1 동시성과 병렬성
- 동시성(Concurrency)과 병렬성(Parallelism)은 비슷하지만 다른 개념 
  - 동시성: 여러 작업이 동시에 진행되는 것처럼 보임 
  - 병렬성: 여러 작업이 실제로 동시에 수행됨

### 14.2 코틀린의 동시성 처리 방법: 일시 중단 함수와 코루틴
- 코틀린은 일시 중단 함수(suspending function)와 코루틴으로 동시성 프로그래밍 지원 
- 일시 중단 함수는 실행을 잠시 멈췄다가 재개할 수 있는 함수

### 14.3 스레드와 코루틴 비교
- 스레드는 OS 수준의 무거운 작업 단위 
- 코루틴은 경량화된 스레드와 같으며, 수천 개도 쉽게 생성 가능 
- 코루틴은 스레드와 달리 일시 중단과 재개가 가능해 효율적

### 14.4 잠시 멈출 수 있는 함수: 일시 중단 함수
- 일시 중단 함수는 suspend 키워드로 선언 
- 다른 일시 중단 함수나 코루틴 내에서만 호출 가능

### 14.4.1 일시 중단 함수를 사용한 코드는 순차적으로 보인다
- 일시 중단 함수는 비동기처럼 동작하지만 코드는 마치 순차적으로 실행되는 것처럼 작성 가능

### 14.5 코루틴을 다른 접근 방법과 비교
- 콜백 지옥(callback hell)과 비교해 코루틴은 가독성이 뛰어남 
- 기존 스레드 기반 비동기 처리 대비 더 간결하고 효율적

### 14.5.1 일시 중단 함수 호출
- 일시 중단 함수 호출은 코루틴 컨텍스트에서 일어나야 하며, suspend 함수 내에서만 직접 호출 가능

### 14.6 코루틴의 세계로 들어가기: 코루틴 빌더
- 코루틴 빌더는 코루틴을 생성하는 함수들 
  - 대표적인 코루틴 빌더: runBlocking, launch, async

### 14.6.1 일반 코드에서 코루틴의 세계로: runBlocking 함수
- runBlocking은 일반 함수 내에서 코루틴을 실행해 결과를 기다림 
- 테스트나 main 함수에서 주로 사용

### 14.6.2 발사 후 망각 코루틴 생성: launch 함수
- launch는 새로운 코루틴을 시작하지만 결과를 기다리지 않음 
- 주로 백그라운드 작업에 사용

### 14.6.3 대기 가능한 연산: async 빌더
- async는 결과를 반환하는 코루틴 빌더
- await()를 통해 결과를 기다릴 수 있음

### 14.7 어디서 코드를 실행할지 정하기: 디스패처
- 디스패처(Dispatcher)는 코루틴이 실행될 스레드를 결정 
- 대표적인 디스패처: Dispatchers.Default, Dispatchers.IO, Dispatchers.Main

### 14.7.1 디스패처 선택
- CPU 연산 집중 작업은 Default 
- 입출력(IO) 작업은 IO 
- UI 작업은 Main

### 14.7.2 코루틴 빌더에 디스패처 전달
- 빌더 함수 인자에 dispatcher 지정 가능

### 14.7.3 withContext를 사용해 코루틴 안에서 디스패처 바꾸기
- withContext를 이용해 특정 블록만 다른 디스패처에서 실행하도록 지정 가능

### 14.7.4 코루틴과 디스패처는 스레드 안정성 문제에 대한 마법 같은 해결책이 아니다
- 코루틴과 디스패처를 써도 스레드 안전 문제는 직접 신경 써야 함 
- 적절한 동기화와 설계 필요

### 14.8 코루틴은 코루틴 콘텍스트에 추가적인 정보를 담고 있다
- 코루틴 컨텍스트는 실행 환경과 상태 정보를 담고 있음 
- 디스패처, Job, 이름 등 다양한 요소 포함