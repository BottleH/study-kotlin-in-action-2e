# PART_11 제네릭스
<br><br>
<hr>

## 다루는 내용

>- 제네릭 함수와 클래스를 정의하는 방법
>- 타입 소거와 실체화된 타입 파라미터
>- 선언 지점과 사용 지점 변성
>- 타입 별명

<hr>
<br><br>

### 11.1 타입 인자를 받는 타입 만들기: 제네릭 타입 파라미터
### 11.1.1 제네릭 타입과 함께 동작하는 함수와 프로퍼티
- 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
- 확장 프로퍼티만 제네릭하게 만들 수 있다.

### 11.1.2 제네릭 클래스를 홑화살괄호 구문을 사용해 선언한다.
- 홑화살괄호<> 를 클래스나 인터페이스 이름 뒤에 붙이면 해당 클래스나 인터페이스를 제네릭하게 만들 수 있다.
```kotlin
interface List<T> {
    operator fun get(index: Int): T
}
```

### 11.1.3 제네릭 클래스나 함수가 사용할 수 있는 타입 제한: 타입 파라미터 제약
- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
```kotlin
fun <T : Number> List<T>.sum() : T
```
- 콜론을 표시하고 그 뒤에 상계 타입을 적으면 된다.
- 타입 파라미터에 대해 둘 이상의 제약을 가하는 경우는 StringBuilder 와 같이 여러 제약을 가할 수 있다.

### 11.1.4 명시적으로 타입 파라미터를 널이 될 수 없는 타입으로 표시해서 널이 될 수 있는 타입 인자 제외시키기
- 아무런 상계를 정하지 않은 타입 파라미터는 Any? 를 상계로 정한 파라미터와 같다.

### 11.2 실행 시점 제네릭스 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
### 11.2.1 실행 시점에 제네릭 클래스의 타입 정보를 찾을 때 한계: 타입 검사와 캐스팅
- 자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
- is 검사를 통해 단어 리스트와 숫자 리스트를 구분하려는 시도는 컴파일 되지 않는다.
- 타입 정보의 크기가 줄어들어 애플리케이션의 전체 메모리 사용량이 줄어든다는 제네릭 타입 소거 나름의 장점이 있다.
- 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅은 항상 성공한다.

### 11.2.2 실체화된 타입 파라미터를 사용하는 함수는 타입 인자를 실행 시점에 언급할 수 있다.
- 코틀린 제네릭 타입의 타입 인자 정보는 실행 시점에 지워진다.
- 인라인 함수의 타입 파라미터는 실체화 된다. 실행 시점에 인라인 함수의 실제 타입 인자를 알 수 있다.
- 성능 향상이 아닌 실체화된 타입 파라미터를 사용하기 위해 인라인 함수를 쓸 수 있다.

### 11.2.3 클래스 참조를 실체화된 타입 파라미터로 대신함으로써 java.lang.Class 파라미터 피하기
```kotlin
inline fun <reified T> loadService() {
    return ServiceLoader.load(T::class.java)
}
```
- 이를 통해 타입 파라미터로 지정된 클래스에 따른 java.lang.Class 를 얻을 수 있고, 그렇게 얻은 클래스 참조를 보통 때와 마찬가지로 사용할 수 있다.

### 11.2.4 실체화된 타입 파라미터가 있는 접근자 정의
- 제네릭 타입에 대해 프로퍼티 접근자를 정의하는 경우 프로퍼티를 inline 으로 표시하고 타입 파라미터를 reified 로 하면 타입 인자에 쓰인 구체적인 클래스를 참조할 수 있다.

### 11.2.5 실체화된 타입 파라미터의 제약
- 다음과 같은 경우에 실체화된 타입 파라미터를 사용할 수 있다.
  - 타입 검사와 캐스팅 (is, !is, as, as?)
  - 코틀린 리플렉션 API (::Class)
  - 코틀린 타입에 대응하는 java.lang.Class 를 얻기 (::class.java)
  - 다른 함수를 호출할 때 타입 인자로 사용
- 다음과 같은 일은 할 수 없다.
  - 타입 파라미터 클래스의 인스턴스 생성하기
  - 타입 파라미터 클래스의 동반 객체 메서드 호출하기
  - 실체화된 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
  - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified 로 지정하기

### 11.3 변성은 제네릭과 타입 인자 사이의 하위 타입 관계를 기술
- 변성 개념은 List<String> 과 List<Any> 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.

### 11.3.1 변성은 인자를 함수에 넘겨도 안전한지 판단하게 해준다.
- 어떤 함수가 리스트의 원소를 추가하거나 변경한다면 타입 불일치가 생길 수 있다. 하지만 원소 추가나 변경이 없는 경우는 안전하다.

### 11.3.2 클래스, 타입, 하위 타입
- 클래스와 타입은 다르다. var x:String, var x:String? 과 같이 클래스가 둘 이상의 타입을 구성할 수 있다.
- 어떤 타입 A 의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 B는 타입 A 의 하위 타입이다.
- 널이 도리 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.
- 무공변: MutableList<Any>, MutableList<String> 은 하위 타입 관계가 아니다.

### 11.3.3 공변성은 하위 타입 관계를 유지한다
- 공변적인 클래스는 제네릭 클래스에 대해 A가 B의 하위 타입일 때 Producer<A> 가 Producer<B> 의 하위 타입인 경우를 말한다.
- 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out 을 넣어야 한다.
- 타입 안정성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에만 있어야 한다.
- 클래스 타입 파라미터 T 앞에 out 키워드를 붙이면 클래스 안에서 T 를 사용하는 메서드가 아웃 위치에서만 T 를 사용하도록 허용하고 인 위치에서는 T를 사용하지 못하게 막는다.

### 11.3.4 반공변성은 하위 타입 관계를 뒤집는다.
- 반공변성: 공변성을 거울에 비친 상이라 할 수 있다.
  - 반공변 클래스의 하위 타입 관계는 그 클래스의 타입 파라미터 상하위 타입 관계와 반대다.
  - 어떤 클래스에 대해 타입 B가 타입 A의 하위 타입일 때 Consumer<A> 가 Consumer<B> 의 하위 타입인 관계가 성립하면 제네릭 클래스는 타입 인자 T 에 대해 반공변이다.

### 11.3.5 사용 지점 변성을 사용해 타입이 언급되는 지점에서 변성 지정
- 선언 지점 변성: 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼친다.
- 사용 지점 변성: 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 그 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 한다.

### 11.3.6 스타 프로젝션: 제네릭 타입 인자에 대한 정보가 없음을 표현하고자 * 사용
- 스타 프로젝션: 제네릭 타입 인자 정보가 없음을 표현 List<*>
- MutableList<*> 는 MutableList<out Any?> 처럼 프로젝션 된다.

### 11.3.7 타입 별명
- 타입 별명: 기존 타입에 대해 다른 이름을 부여한다. typealias 키워드 뒤에 별명을 적어 시작할 수 있다.

