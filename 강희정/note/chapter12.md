# 12장. 어노테이션과 리플렉션

어노테이션

- 라이브러리가 요구하는 의미를 클래스에 부여

리플렉션

- 실행 시점에 컴파일러 내부 구조 분석

# 12.1 어노테이션 선언과 적용

어노테이션 사용 → 선언에 추가적인 메타데이터를 연관시킬 수 있다.

어노테이션이 설정된 방식에 따라 메타데이터를 소스코드, 컴파일된 클래스 파일, 런타임에 대해 작동하는 도구를 통해 접근할 수 있다.

## 12.1.1 어노테이션을 적용해 선언에 표지 남기기

- @와 어노테이션 이름을 선언 앞에 넣으면 코드 구성 요소에 어노테이션 붙일 수 있음
- @Test, @Deprecated 등
- 어노테이션은 인자도 받을 수 있음
    - 클래스를 어노테이션 인자로 지정
        - ::class를 클래스 이름 뒤에 넣어야 함
        - @MyAnnotation(Myclass::class)
    - 다른 어노테이션을 인자로 지정
        - 인자로 들어가는 어노테이션 이름 앞에 @를 넣으면 안 됨
    - 배열을 인자로 지정
        - 각괄호 사용
        - @RequestMapping(path = [”/foo”, “/bar”]
        - arrayOf 함수 사용 가능
- 어노테이션 인자는 컴파일 시점에 알 수 있어야 함
    - 임의의 프로퍼티를 인자로 지정할 수 없음
    - 프로퍼티를 어노테이션 인자로 지정하려면 그 앞에 const 변경자를 붙여야 함
        - 파일의 최상위나 object 안에 선언
        - 기본 타입이나 String으로 초기화 필요

## 12.1.2 어노테이션이 참조할 수 있는 정확한 선언 지정: 어노테이션 타깃

어노테이션을 붙일 때 어떤 요소에 어노테이션을 붙일지 표시

사용 지점 타겟 선언

```kotlin
@get:JvmName("obtainCertificate")
```

- @get: 사용 지점 타깃
- JvmName: 어노테이션 이름
- @JvmName 어노테이션을 프로퍼티 게터에 적용

자바에 선언된 어노테이션을 사용해 프로퍼티에 어노테이션을 붙이는 경유

→ 프로퍼티의 필드에 그 어노테이션이 붙는다

코틀린으로 어노테이션 선언 → 프로퍼티에 직접 적용할 수 있는 어노테이션이 붙음

코틀린이 지원하는 어노테이션 타깃 목록

- property: 프로퍼티 전체
- field: 프로퍼티에 의해 생성되는 필드
- get: 프로퍼티 게터
- set: 프로퍼티 세터
- receiver: 확장 함수나 프로퍼티의 수신 객체 파라미터
- param: 생성자 파라미터
- setparam: 세터 파라미터
- delegate: 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
- file
    - 파일 안에 선언된 최상위 함수와 프로퍼티를 담아둠
    - package 선언보다 더 앞에만 넣을 수 있음
    - @JvmName

어노테이션 인자로 클래스 또는 함수 선언이나 타입 외에 임의의 식을 허용함.

자바 API를 어노테이션으로 제어하기

- @JvmName
    - 코틀린 선언이 만들어내는 자바 필드나 메서드 이름을 변경
- @JvmStatic
    - 객체 선언이나 동반 객체 메서드에 적용하면 메서드가 자바 정적 메서드로 노출됨
- @JvmOverloads
    - 디폴트 파라미터 값이 있는 함수에 대해 컴파일러가 자동으로 오버로딩한 함수를 생성해줌
- @JvmFields
    - 대상 프로퍼티를 게터나 세터가 없는 public 자바 필드로 노출시킴
- @JvmRecords
    - data class에 선언하면 자바 레코드 클래스를 선언할 수 있음

## 12.1.3 어노테이션을 활용해 JSON 직렬화 제어

직렬화

- 객체를 저장 장치에 저장하거나 네트워크를 통해 전송하기 위해 텍스트나 이진 형식으로 변환하는 것

역직렬화

- 텍스트나 이진 형식으로 저장된 데이터에서 원래의 객체를 만들어 냄

어노테이션을 활용해 직렬화/역직렬화 방법 제어 가능

- @JsonExclude
    - 직렬화나 역직렬화 때 무시해야 할 프로퍼티 표시
    - 직렬화 대상에서 제외할 프로퍼티에는 기본값 지정 필요 → 역직렬화 할 때 인스턴스 만들 때 필요함
- @JsonName
    - 프로퍼티를 표현하는 키/값 쌍의 키로 프로퍼티 이름 대신 어노테이션이 지정한 문자열을 쓰게 함

## 12.1.4 어노테이션 선언

```kotlin
annotation class JsonExclude
```

- 선언이나 식과 관련 있는 메타데이터의 구조만 정의
- 내부에 나무 코드도 들어있을 수 없음
- 컴파일러는 어노테이션 클래스에서 본문을 정의하지 못하게 막는다

파라미터가 있는 어노테이션 정의

```kotlin
annotation class JsonName(val name: String)
```

- 어노테이션 클래스의 주 생성자에 파라미터를 선언해야 함
- 어노테이션 클래스의 경우 반드시 모든 파라미터가 val이어야 함

자바 어노테이션 선언과의 비교

- 자바 어노테이션에넌 value 메서드가 있음
    - 어노테이션을 적용할 때 value를 제외한 모든 애트리뷰트에는 이름을 명시해야 함
- 코틀린 어노테이션에는 name 프로퍼티가 있음
- 코틀린에서 어노테이션 적용 문법은 일반적인 생성자 호출과 같음
    - named argument 인자 구문을 사용할 수도 있고 인자 이름을 모두 생략할 수도 있음
- 자바에서 선언한 어노테이션을 코틀린의 구성 요소에 적용할 때는 value를 제외한 모든 인자에 대해 named argument 인자 구문을 사용해야 함

## 12.1.5 메타어노테이션: 어노테이션을 처리하는 방법 제어

메타어노테이션

- 어노테이션 클래스에 적용할 수 있는 어노테이션
- 예시: @Target
    - 어노테이션을 적용할 수 있는 요소의 유형을 지정
    - 어노테이션 클래스에 구체적인 @Target을 지정하지 않으면 모든 선언에 적용할 수 있는 어노테이션이 됨
    - AnnotationTarget: 어노테이션이 붙을 수 있는 Target이 지정됨

@Retention

- 정의 중인 어노테이션을 어느 수준까지 유지할지를 지정하는 메타어노테이션
    - 소스 수준, .class 파일 수준, 실행 시점 등등
- 코틀린은 디폴트가 RUNTIME

## 12.1.6 어노테이션 파라미터로 클래스 사용

```kotlin
annotation class DeserializeInterface(val targetClass:: KClass<out Any>)
```

- 클래스를 인자로 넣으려면 ::class 키워드를 붙여야 함
- KClass의 타입 파라미터 : KClass의 인스턴스가 가리키는 코틀린 타입을 지정

## 12.1.7 어노테이션 파라미터로 제네릭 클래스 받기

```kotlin
annotation class CustomSerializer (
		val serializerClass: KClass<out ValueSerializer<*>>
)
```

- 제네릭 클래스인 ValueSerializer 타입을 참조하려면 항상 타입 인자를 제공해야 함
- 이 어노테이션이 어떤 타입에 대해 쓰일지 전혀 알 수 없으므로 스타 프로젝션을 인자로 사용
- 클래스를 어노테이션 인자로 받아야 할 때 → KClass<out 자신의 클래스 이름>
- 클래스 이름 자체가 타입 인자를 받아야 할 때 → KClass<out 자신의 클래스 이름<*>> (타입 인자를 *로 바꿈)

# 12.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰

리플렉션

- 실행 시점에 동적으로 객체의 프로퍼티와 메서드에 접근할 수 있게 해 주는 방법
- 컴파일러는 그런 이름이 실제로 가리키는 선언을 정적으로 컴파일 시점에 찾아내 해당하는 선언이 실제 존재함을 보여줌
- 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메서드나 프로퍼티 이름을 실행 시점에만 알 수 있는 경우가 존재 → 리플렉션 사용
- 코틀린 리플렉션 API는 코틀린 리플렉션만 다룰 수 있는 것이 아니라 다른 JVM 언어에서 생성한 바이트코드 또한 다룰 수 있음
- 리플렉션을 사용하는 자바 라이브러리와 코틀린 코드가 완전히 호환됨
- 코틀린 리플렉션 API를 사용하려면 직접 프로젝트 의존관계에 리플렉션 라이브러리 추가 필요
    - `org.jetbrains.kotlin:kotlin-reflect`

## 12.2.1 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty

KClass

- 클래스를 표현
- 클래스 안에 있는 모든 선언을 열거
- 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 작업 가능

```kotlin
interface KClass<T: Any> {
		val simpleName: String?
		val qalifiedName: String?
		val members: Collection<KCallable<*>>
		val constructors: Collection<Function<T>>
		val nestedClasses: Collection<KClass<*>>
}
```

KCallable

- 함수와 프로퍼티를 아우르는 공통 상위 인터페이스
- 모든 멤버의 컬렉션인 members가 KCallable의 인터페이스
- call 메서드를 포함하고 있음
- call을 사용하면 함수나 프로퍼티 게터 호출 가능

```kotlin
interface KCallable<out R>{
		fun call(vararg args: Any?): R
}
```

KFunctionN

- 함수의 파라미터가 N개라는 뜻
- 인터페이스를 통해 함수를 호출하려면 invoke 메서드 사용
- 컴파일러가 생성한 합성 타입 → 인자 개수가 무제한

KProperty

- 모든 프로퍼티 표현
    - KMutableProperty
        - var로 정의한 변경 가능한 프로퍼티 표현
- call, get 호출 가능
- get 메서드 접근 → 프로퍼티가 선언된 방법에 따라 올바른 인터페이스 사용 필요
- 최상위 읽기 전용가 가변 프로퍼티는 KProperty0이나 KMutableProperty0 인터페이스의 인스턴스로 표현되며 둘 다 인자가 없는 get 메서드를 제공
- 최상위 수준이나 클래스 안에 정의된 프로퍼티만 리플렉션으로 접근할 수 있고 함수의 로컬 변수에는 접근할 수 없음
- Getter/Setter로 프로퍼티 접근자를 함수처럼 다룰 수 있음
    - KFunction의 확장

## 12.2.4 JSON 파싱과 객체 역직렬화

역직렬화 과정에서 올바른 결과를 만들어내려면 → 실행 시점에 타입 파라미터 접근 필요 → reified 타입 파라미터 필요 → inline 함수 선언 필요

렉서

- 어휘 분석기
- 문자역을 토큰 리스트로 바꿔줌
- 여러 문자로 이뤄진 입력 문자열을 토큰의 리스트로 변환
    - 문자 토큰: 문자를 표현하면 JSON 문법에서 중요한 의미를 함
    - 값 토큰: 문자열, 수, 불리언 값, null 상수

파서

- 토큰의 리스트를 구조화된 표현으로 변환
- 어휘 분석기가 만든 토큰 리스트를 분석화하면서 의미 단위를 만날 때 마다 JsonObject의 메서드를 적절히 호출

역직렬화 컴포넌트

- 파싱한 결과로 객체를 생성

## 12.2.5 callBy()와 리플렉션을 사용해 객체 만들기

KCallable.call

- 인자 리스트를 받아 함수나 생성자를 호출
- 디폴트 파라미터 값을 지원하지 않음

KCallable.callBy

- 디폴트 파라미터 값을 지원

KType의 실행 시점 표현을 얻기 위해 typeOf<T> 함수 사용