# 16장. 플로우

# 16.1 플로우는 연속적인 값의 스트림을 모델링한다

플로우

- 시간이 지남에 따라 나타나는 값과 작업할 수 있게 해주는 코틀린 기반의 추상화
- 함수가 실행을 마칠 때 까지 기다리지 않고 값을 사용할 수 있도록 비동기적으로 반환
- 점진적인 로딩, 이벤트 스트림 작업, 구독 스타일 API 모델링하는데 사용

## 16.1.1 플로우 사용 → 배출되자마자 원소 처리

- 생성을 위해서는 flow
- 원소를 추가하려면 emit
- 플로우의 원소를 순회하려면 collect

```kotlin
fun createValues(): Flow<Int> {
		return flow {
				emit(1)
				delay(1000.milliseconds)
				emit(2)
				delay(1000.milliseconds)
				emit(3)
				delay(1000.milliseconds)
		}
}

fun main() = runBlockingg {
		val myFlowOfValues = createValues()
		myFlowOfValues.collect { log(it) }
}
```

- 배출된 원소는 수집자(collect 실행)에 의해 처리
- 값이 배출되자마자 출력됨

→ 값이 계산되자마자 이를 사용 가능한 추상화가 플로우의 핵심 개념

## 16.1.2 코틀린 플로우의 여러 유형

콜드 플로우

- 비동기 데이터 스트림
- 값이 실제로 소비되기 시작할 때만 값을 배출

핫 플로우

- 값이 실제로 소비되고 있는지와 상관없이 값을 독립적으로 배출
- 브로드캐스트 방식으로 동작

# 16.2 콜드 플로우

## 16.2.1 콜드 플로우 생성

- flow 빌더 함수를 사용하여 생성
- emit을 호출해 플로우의 수집자에게 값을 제공
- 수집자가 해당 값을 처리할 때까지 빌더 함수의 실행 중단
- flow가 받는 블록은 suspend 변경자 → 빌더 내부에서 delay와 같은 일시 중단 함수 호출 가능

## 16.2.2 콜드 플로우는 수집되기 전까지 작업을 수행하지 않음

수집자(collector)

- 플로우를 수집하는 코드
- 플로우에서 배출된 각 원소에 대해 호출될 람다 제공
- collect 함수 호출
    - 일시 중단 함수
    - 플로우가 끝날 때 까지 일시 중단
    - 플로우에 무한한 원소가 있으면 → collect도 무기한 일시 중단
- 수집자의 코루틴을 취소하면 → 다음 취소 지점에서 플로우 수집이 중단

## 16.2.4 콜드 플로우의 내부 구현

플로우 → 일시 중단 함수와 수신 객체 지정 람다를 결합한 조합

플로우의 정의

- 2가지 인터페이스
    - Flow → collect 정의
    - FlowCollector → emit 정의
- flow의 구조
    - collect를 호출하면 플로우 빌더 함수의 본문이 실행
    - 본문이 emit 호출 → emit에 전달된 파라미터로 collect에 전달된 람다가 호출
    - 람다 표현식이 실행을 완료하면 함수는 빌더 함수의 본문으로 돌아가 계속 실행

## 16.2.5 채널 플로우를 사용한 동시성 플로우

일반적인 플로우의 특징

- 순차적으로 실행
- 동일한 코루틴에서 실행
    - 같은 코루틴 안에서만 emit 허용

채널 플로우

- 여러 코루틴에서 배출을 허용 (동시성 플로우)
- 콜드 플로우의 특별한 유형
- emit대신 send를 사용해 값을 제공
- collect가 값을 수신
- channelFlow 람다는 새로운 백그라운드 코루틴을 시작할 수 있는 코루틴 스코프 제공

### 콜드 플로우 vs. 채널 플로우

콜드 플로우

- 간단하고 성능이 좋음
- 순차 실행

채널 플로우

- 동시 작업
- 비용이 든다
- 플로우 안에서 새로운 코루틴을 시작할 때 사용

# 16.3 핫 플로우

여러 구독자라고 불리는 수집자들이 배출된 항목을 공유

수집자가 존재하는지 여부에 상관 없이 값을 배출하는 경우에 사용

항상 활성 상태

핫 플로우의 종류

- 공유 플로우: 브로드캐스팅
- 상태 플로우: 상태 전달

→ 상태 플로우가 더 자주 사용

## 16.3.1 공유 플로우: 값을 구독자에게 브로드캐스트

수집자가 존재하는지 여부에 상관없이 배출이 발생

컨테이너 클래스 안에 선언

- 값 배출 공유 플로우 → private 속성으로 캡슐화
- 값 배출 구독 플로우 → public 속성으로 노출

원소가 공유 플로우에 배출되면 플로우를 수집하고 있는 모든 구독자가 원소를 수신함

배출이 구독자 유무에 관계없이 발생 → 사용자가 배출을 수행하는 코루틴을 시작할 책임이 있음

구독자 추가 → collect 호출

배출이 발생할 때마다 제공한 람다가 실행

→ but, 구독자는 구독 시작 이후에 배출된 값만 수신함!!

같은 공유 플로우를 구독하는 모든 구독자와 똑같은 값을 수신

### 구독자를 위한 값 재생

MutableSharedFlow 생성 시 replay 사용

→ 새 구독자를 위해 제공할 값의 캐시 설정 가능

### 콜드 플로우를 공유 플로우로 전환

- shareIn으로 전환
- 주어진 콜드 플로우를 공유 플로우로 변환
- shareIn을 코틀린 안에서 호출
    - CoroutineScope타입의 scope 파라미터를 받아서 코루틴을 실행
    - started 파라미터 : 플로우가 실제로 언제 시작되어야 하는지 정의
        - 여러 동작 지정 가능
            - Eagerly: 플로우 수집 즉시 시작
            - Lazily: 첫 번째 구독자가 나타나야만 시작
            - WhileSubscribed: 첫 번째 구독자가 나타나야 수집 시작, 마지막 구독자가 사라지면 플로우 수집 취소
    - 구조적 동시성에 참여 → 공유 플로우를 둘러썬 코루틴 스코프가 취소되면 공유 플로우 내부 로직도 자동으로 취소됨

## 16.3.2 시스템 상태 추적: 상태 플로우

상태 플로우

- 변수의 상태 변화를 쉽게 추적

생성

- 공유 플로우를 생성하는 것과 비슷
- private으로 flow 생성
- public으로 읽기 전용 뷰 노출

시간이 지남에 따라 변경될 수 있는 값을 나타냄 → 생성자에게 초깃값 제공

update: 값을 갱신하는 함수로 사용

현재 상태를 value 속성으로 접근 가능

### UPDATE 함수로 안전하게 상태 플로우에 쓰기

- value는 가변 속성이지만 일반 연산자를 사용하면 연산이 원자적이지 않음
    - 코루틴이 여러 스레드에서 실행되기 때문
- update 함수
    - 원자적으로 값을 갱신
    - 이전 값을 기반으로 새 값을 어떻게 계산해야 하는지 정하는 람다 표현식을 인자로 받음
    - 두 갱신이 병렬적으로 발생하면 새로 읽은 previous 값을 사용해 한번 더 갱신 함수를 실행 → 어떤 연산도 손실되지 않게 함

### 동등성 기반 통합

값이 실제로 변경되었을 때만 구독자에게 값을 배출한다

이전 값과 새 값이 같으면 배출하지 않음

### stateIn으로 콜드 플로우를 상태 플로우로 변환

## 16.3.3 상태 플로우와 공유 플로우의 비교

공유 플로우

- 구독자가 구독하는 동안만 이벤트 배출
- 구독자가 들어오고 나갈 수 있음
- 배출이 예상되는 시점에 구독자가 존재한다는 사실을 보장하는 책임이 사용자에게 있음

상태 플로우

- 상태를 나타냄
- 동등성 기반 통합
- 상태 플로우가 나타내는 값이 실제로 변경될 때만 배출이 발생
- 공유 플로우보다 API가 간단