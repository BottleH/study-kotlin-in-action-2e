# 11장. 제네릭스

# 11.1 타입 인자를 받는 타입 만들기: 제네릭 타입 파라미터

제네릭스

- 클래스나 함수가 사용하는 타입을 나중에 지정할 수 있게 하는 기능
- 인스턴스가 만들어질 때 타입 파라미터를 구체적인 타입 인자로 치환

코틀린에서는 raw 타입을 허용하지 않음

- 자바에서는 타입 인자가 없는 제네릭 타입(raw type)을 허용
    - `ArrayList list = new ArrayList();`
- 코틀린에서는 raw타입 지원하지 않음.
    - 자바의 raw타입을 코틀린에서 받으려면 → Any!타입으로 간주

## 11.1.1 제네릭 타입과 함께 동작하는 함수와 프로퍼티

제네릭 함수

- 특정 타입을 가지고 연산하는 것이 아닌 여러 타입으로 연산
- 그 자신이 타입 파라미터를 받음
- 단, 호출 시 구체적인 타입으로 타입 인자를 넘겨야 함

```kotlin
fun<T> List<T>.slice(indices: IntRange): List<T>
```

- 타입 파라미터가 수신 객체와 반환 타입에 사용됨

타입 파라미터

- 클래스나 인터페이스 안에 정의된 메서드, 최상위 함수, 확장 함수에서 선언
- 확장 함수 → 수신객체나 파라미터 타입에 사용
- 제네릭 확장 프로퍼티 선언 가능
    - 일반 프로퍼티는 타입 파라미터를 가질 수 없다

## 11.1.2 제네릭 클래스 선언

타입 파라미터를 넣은 <>로 선언. 선언 후에는 클래스 본문 안에서 다른 일반 타입처럼 사용

```kotlin
interface List<T> {
		operator fun get(index: Int): T
}
```

## 11.1.3 타입 파라미터 제약

타입 파라미터 제약

- 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 upper bound로 지정하면 → 그 제네릭 타입을 인스턴스화 할 때 사용하는 타입 인자는 반드시 그 상계 타입이거나 그 상계 타입의 하위 타입이어야 한다

```kotlin
fun <T: Number> List<T>.sum(): T
```

- 상계가 Number타입이 원소 타입인 리스트만으로 제한

## 11.1.4 명시적으로 타입 파라미터를 널이 될 수 없는 타입으로 제한 → 널이 될 수 있는 타입 인자 제외시키기

아무런 상계를 정하지 않은 타입 파라미터 → Any?를 상계로 정한 파라미터와 같다.

널 가능성을 제외하려면 → Any 필요(항상 널이 될 수 없는 타입)

T & Any

- Java와 상호운영 시 사용
- 타입을 정의한 시점이 아닌 사용하는 시점에서 절대로 널이 될 수 없다고 표시

```kotlin
class KBox<T>: JBox<T> {
		override fun put(t: T & Any) { /* ... */ }
		override fun putIfNotNull(t: T) { /* ... */ }
}
```

# 11.2 실행 시점 제네릭스 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

타입 소거

- 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자의 정보가 들어있지 않음
- JVM의 제네릭스는 보통 타입 소거를 사용
- 함수를 inline으로 만들면 타입 인자가 지워지지 않게 할 수 있음 (refied)

## 11.2.1 실행 시점에 제네릭 클래스의 타입 정보를 찾을 때 한계: 타입 검사와 캐스팅

코틀린 제네릭 타입 인자 정보 → 런타임에 지워짐

제네릭 클래스 인스턴스 → 인스턴스 생성 할 때 쓰인 타입 인자에 대한 정보를 유지하지 않음

```kotlin
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)
```

- 실행 시점에 list1이나 list2가 문자열이나 정수의 리스트로 선언되었다는 사실을 알 수 없음 - 각 객체는 단지 List일 뿐
- 실행 시점에 이 둘은 완전히 같다

타입 소거로 인해 생기는 한계

- 실행 시점에 타입 인자를 검사할 수 없음

제네릭 타입의 사용

- as나 as? 캐스팅에도 사용 가능 → 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로 캐스팅 성공
- 컴파일 시점에 타입 정보가 주어진 경우에는 is검사를 수행하게 허용

## 11.2.2 refied 타입 파라미터를 사용하는 함수 → 타입 인자를 실행 시점에 언급할 수 있다

기본적으로 제네릭 타입의 타입 인자 정보는 - 실행 시점에 지워짐

인라인 함수의 타입 파라미터 → 실체화

→ 실행 시점에 인라인 함수의 실제 타입 인자를 알 수 있다.

```kotlin
inline fun <reified T> isA(value: Any) = value is T
```

- value의 타입이 T의 인스턴스인지를 실행 시점에 검사 가능

인라인 함수에서만 refied 타입 인자를 사용할 수 있는 이유

- 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입
- 컴파일러는 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있음
- 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입 가능

Java에서는?

- reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없음
- 코틀린 인라인 함수를 다른 보통 함수처럼 호출
    - 인라인 함수를 호출해도 실제로 인라이닝이 되지는 않음

## 11.2.5 reified 타입 파라미터의 제약

reified 파라미터를 사용할 수 있는 경우

- 타입 검사와 캐스팅
- 코틀린 리플렉션 API
- 코틀린 타입에 대응하는 java.lang.Class를 얻기
- 다른 함수를 호출할 때 타입 인자로 사용

할 수 없는 일

- 타입 파라미터 클래스의 인스턴스 생성
- 타입 파라미터 클래스의 companion object 메서드 호출
- reified 타입 파라미터를 요구하는 함수를 호출하면서 reified하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
- 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기

→ reified 타입 파라미터를 인라인 함수에만 사용할 수 있으므로 → reified 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든 람다를 인라이닝한다.

# 11.3 변성은 제네릭과 타입 인자 사이의 하위 타입 관계를 기술

Variance

- 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념

## 11.3.2 클래스, 타입, 하위 타입

제네릭 클래스가 아닌 클래스 → 클래스 이름을 바로 타입으로 쓸 수 있음

`var x: String`

- String 클래스의 인스턴스를 저장하는 변수 정의
- var x: String?으로 쓰면 nullable한 타입에도 사용 가능

→ 모든 코틀린 클래스가 적어도 둘 이상의 타입을 구성할 수 있다.

제네릭 클래스

- 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다
- ex)
    - List는 타입이 아님
    - List<Int>, List<String?>, List<List<String>>은 모두 타입
- 각각의 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있음

하위 타입

- 어떤 타입 A의 값이 필요한 모든 장소에 → 어떤 타입 B의 값을 넣어도 아무 문제가 없으면
    - B는 A의 하위 타입이다.
- 모든 타입은 자신의 하위 타입이다.
- 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행함
- 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 → 값을 변수에 대입하도록 허용
- 함수에 전달하는 식의 타입이 함수 파라미터 타입의 하위 타입인 경우에만 → 함수 호출이 허용
- 하위 타입 → 하위 클래스와 근본적으로 같다.
- 어떤 인터페이스를 구현하는 클래스의 타입은 → 그 인터페이스 타입의 하위 타입이다.
- non-nullable한 타입은 nullable 타입의 하위 타입이다 → 하지만 두 타입은 같은 클래스!

invariant(무공변)

- 서로 다른 타입 A와 B에 대해 MutableList<A>가 MutableList<B>의 하위 타입도 아니고 상위 타입도 아닌 경우 → 제네릭 타입이 타입 파라미터에 대해 invariant
- 자바는 모든 클래스가 invariant

## 11.3.3 공변성 → 하위 타입 관게를 유지

covariant(공변)

- A가 B의 하위 타입이면 Producer<A>는 Producer<B>의 하위 타입이다.
- 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 함

```kotlin
interface Producer<out T> {
		fun produce(): T
}
```

- 클래스의 타입 파라미터를 공변적으로 만들면 → 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 → 클래스의 인스턴스를 함수 인자나 반환값으로 사용할 수 있다.

- 모든 클래스를 공변적으로 만들 수 없음 → 공변적으로 만들면 안전하지 못한 클래스도 있음
- 타입 파라미터를 공변적으로 지정하면 → 클래스 내부에서 그 파라미터를 사용하는 방법을 제한함
- 타입 안정성을 보장하기 위해 → 공변적 파라미터는 항상 아웃 위치에만 있어야 함 → 클래스가 T 타입의 값을 생산할 수는 있지만 소비할 수는 없다.

in, out

- 클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점
- out
    - T라는 타입 파라미터를 선언하고 T를 사용하는 함수가 멤버로 있는 클래스
    - T가 함수의 반환 타입에 사용
    - 함수는 T타입의 값을 생산
    - in 위치에 사용하지 못하도록 제한
    - T로 인해 생기는 하위 타입 관계의 타입 안정성 보장
- in
    - T가 함수의 파라미터 타입에 쓰일 때
    - T타입의 값을 소비

타입 파라미터에 붙은 out의 의미

- 하위 타입 관계가 유지된다
- T를 아웃 위치에서만 사용할 수 있다.

생성자 파라미터 → in/out 어느 쪽도 아니다.

타입 파라미터가 out이라 하더라도 그 타입을 여전히 생성자 파라미터 선언에 사용할 수 있다.

변성

- 코드에서 위험할 여지가 있는 메서드를 호출할 수 없게 만듦
- 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 하용하는 일이 없게 방지
- 생성자 → 나중에 호출할 수 있는 메서드가 아님 → 위험할 여지가 없음
    - val/var 키워드를 생성자 파라미터에 적는다면 → 게터와 세터를 정의하는 것과 같다.
- 변성 규칙은 public, protected, internal 클래스 API에서만 적용할 수 있다.
- private 메서드의 파라미터는 인도 아니고 아웃도 아닌 위치
- 클래스 내부 구현에는 적용되지 않는다.

## 11.3.4 contravariance: 하위 타입 관계를 뒤집는다

contravariace

- 하위 타입 관계는 그 클래스의  타입 파라미터의 상하위 타입 관계와 반대
- 어떤 클래스에 대해 타입 B가 타입 A의 하위 타입일 때 → Consumer<A>가 Consumer<B>의 하위 타입인 관계가 성립하면 → 제네릭 클래스는 타입 인자 T에 대해 반공변

in

- 키워드가 붙은 타입이 이 클래스의 메서드 안으로 전달되어 메서드에 의해 소비된다는 뜻
- 타입 파라미터의 사용을 제한함 - 타입 인자를 오직 인 위치에서만 사용할 수 있다.

공변성, 반공변성, 무공변성 클래스

| 공변성 | 반공변성 | 무공변성 |
| --- | --- | --- |
| Producer<out T> | Consumer<in T> | MutableList<T> |
| 타입 인자의 하위 타입 관계가 제네릭 타입에서도 유지된다. | 타입 인자의 하위 타입 관계가 제네릭 타입에서 뒤집힌다. | 하위 타입 관계가 성립하지 않는다. |
| Producer<Cat>은 Producer<Animal>의 하위 타입이다. | Consumer<Animal>은 Consumer<Cat>의 하위 타입이다. |  |
| T를 아웃 위치에서만 사용할 수 있다. | T를 인 위치에서만 사용할 수 있다. | T를 아무 위치에서나 사용할 수 있다. |

어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수도 있음.

## 11.3.5 사용 지점 변성 - 타입이 언급되는 지점에서 변성 지정

선언 지점 변성

- 클래스를 선언하면서 변성 지정
- 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼침

사용 지점 변성

- 타입 파라미터가 있는 타입을 사용할 때
- 그 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시
- 클래스 안에서 어떤 타입 파라미터가 공변적이거나 반공변적인지 선언할 수 없는 경우에도 → 사용 지점 변성 가능
- 코틀린의 사용 지점 변성 → 자바의 한정 와일드카드와 같다.

타입 프로젝션

- 제네릭 타입의 읽기/쓰기 방향을 제한해서 안전하게 사용하는 방법
- in, out, * 등을 통해 제네릭 타입 인자를 정확히 모르거나 제한해야 할 때 사용하는 타입 안전 장치
- 파라미터 타입, 로컬 변수 타입, 함수 반환 타입 등에 타입 파라미터가 쓰이는 경우 사용

## 11.3.6 스타 프로젝션: 제네릭 타입 인자에 대한 정보가 없을 표현하고자 할 때

스타 프로젝션

- 제네릭 타입 인자 정보가 없음을 표현
    - List<*> : 제네릭 타입 인자 정보가 없음을 표현
    - MutableList<*> : 어떤 정해진 구체적인 타입의 원소만을 담는 리스트지만 그 원소의 타입을 정확히 모른다
- 반공변 타입 파라미터에 대한 스타 프로젝션 → <in Nothing>과 동등함
- 타입 파라미터가 반공변이변 → 제네릭 클래스는 소비자 역할을 함 → 어떤 대상을 소비할 지 알 수 없음
- 타입 인자에 대한 정보가 중요하지 않을 때 사용
- 타입 파라미터를 시그니처에서 전혀 언급하지 않거나 데이터를 읽기는 하지만 구체적인 타입은 신경쓰지 않을 때 사용
- 제네릭 타입 파라미터가 어떤 타입인지 굳이 알 필요가 없을 때만 사용
- 값을 만들어내는 메서드만 호출할 수 있고 그 값의 타입에는 신경쓰지 말아야 한다.

## 11.3.7 type alias

type alias

- 기존 타입에 대해 다른 이름을 부여함

```kotlin
typealias NameCombiner = (String, String, String, String) -> String
```

- 가독성만 좋지 타입 안정성을 보장해주지는 않음