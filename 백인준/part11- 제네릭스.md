# 📚 11장 제네릭스

- 선언 지점 변성을 사용하면 기저 타입은 같지만 타입 인자가 다른 두 제네릭 타입이 있을 때 타입 인자의 상하위 타입 관계에 따라
  두 제네릭 타입의 상하위 타입 관계가 어떻게 되는지 지정할 수 있다.
- 사용 지점 변성은 제네릭 타입 값을 사용하는 구체적인 위치에서 같은 목표를 달성한다.
    - 자바의 와일드 카드와 같은 역할

___

## 📖 11.1 타입 인자를 받는 타입 만들기: 제네릭 타입 파라미터

- 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할수 있다.
- 제네릭 타입의 인스턴스가 만들어질 때는 타입 파라미터를 구체적인 타입 인자로 치환한다.
- 코틀린 컴파일러는 보통 타입과 마찬가지로 타입인자도 추론 가능
- 빈 리스트를 만들어야 한다면 타입 인자를 추론할 근거가 없기 때문에 직접 타입 인자를 명시해야 한다.

```kotlin
var readers: MutableList<String> = mutableListOf()
var readers = mutableListOf<String>()
```

- 두 선언은 동등

### 🔖 11.1.1 제네릭 타입과 함께 동작하는 함수와 프로퍼티

- 제네릭 함수는 그 자신이 타입 파라미터를 받는다.
- 제네릭 함수를 호출할 때는 반드시 구체적인 타입으로 타입 인자를 넘겨야 한다.
- 함수의 타입 파라미터가 T가 수신 객체와 반환 타입에 쓰인다.
- 수신객체와 반환 타입 모두 List<T>다.
    - 이런 함수를 구체적은 리스트에 대해 호출할 때 타입 인자를 명시적으로 지정할 수 있다.

```kotlin
fun main() {
    val authors = listOf("sveta")
    val readers = mutableListOf<String>("seb")
    println(readers.filter { it !in authors })
}
```

- 람다 파라미터에 대해 자동으로 만들어진 변수 it의 타입은 여기서 String 이다. 컴파일러는 이를 추론해야만 한다.
- 클래스나 인터페이스 안에 정의된 메서드, 최상위 함수, 확장 함수에서 타입 파라미터를 선언할수 있다.
- 제네릭 함수를 정의할 때와 마찬가지 구문으로 제네릭 확장 프로퍼티를 선언할수 있다.

### 🔖 11.1.2 제네릭 클래스를 홑화살괄호 구문을 사용해 선언한다.

- 자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 홑화살괄호를 클래스나 인터페이스 이름 뒤에 붙이면 해당 클래스나 인터페이스를
  제네릭하게 만들수 있다.
- 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다.
- 심지어 클래스가 자신을 타입인자로 참조할 수도 있다.

### 🔖 11.1.3 제네릭 클래스나 함수가 사용할 수 있는 타입 제한: 타입 파라미터 제약

- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한 하는 기능
- 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상계로 지정하면 그 제네릭 타입을 인스턴스화 할때 사용하는 타입 인자는 반드시 그 상계
  타입이거나 그 상계 타입의 하위 타입이어야 한다.
- 타입 파라미터 T에 대한 상계를 정하고 나면 T타입의 값을 그 상계 타입의 값으로 취급 할수 있다.
- <T:Any> 라는 제약은 T타입이 항상 널이 될수 없는 타입이 되도록 보장한다.

### 🔖 11.2.4 실체화된 타입 파라미터가 있는 접근자 정의

- 인라인과 실체화된 타입 파라미터를 사용할 수 있는 코틀린 구성 요소가 함수만 있는것은 아니다.
- 제네릭 타입에 대해 프로퍼티 접근자를 정의하는 경우 프로퍼티를 inline으로 표시하고 타입 파라미터를 reifired로 하면 타입 인자에 쓰인
  구체적인 클래스를 참조할수 있다.

### 🔖 11.2.5 실체화되뉴 타입 파라미터 제약

- 실체화된 파라미터 사용 가능 경우
    - 타입 검사와 캐스팅(is,!is ,as, as?)
    - 10 장에서 설명할 코틀린 리플렉션 API
    - 코틀린 타입에 대응하는 java.lang.class를 얻기
    - 다른 함수를 호출할 때 타입 인자로 사용
- 다음과 같은일은 불가능
    - 타입 파라미터 클래스의 인스턴스 생성하기
    - 타입 파라미터 클래스의 동반 객체 메서드 호출하기
    - 실체화된 타입 파라미터를 요구하는 함수를 호출하면서 실체화 하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
    - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified 로 지정하기
- 실체화된 타입 파라미터를 인라인 함수에만 사용할 수 있으므로 실체화된 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든
  람다를 인라이닝 한다.

### 🔖 11.3.2 클래스, 타입, 하위 타입

- 제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸수 있다.
- 모든 코틀린 클래스가 적어도 둘 이상의 타입을 구성할수 있다는 뜻이다.
- 제네릭 클래스는 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
- 각각의 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있다.
- 하위 타입
    - 어떤 타입의 A값이 필요한 모든 장소에 어떤 타입 B값을 넣어도 아무 문제가 없다면 B는 A의 하위 타입이다.
- 상위 타입
    - 하위 타입의 반대이다.
    - A타입이 B타입의 하위타입이라면 B는 A의 상위타입이다.
- 널이 될수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다. 하지만 두 타입은 모두 같은 클래스에 해당한다.
- 하위 타입도 아니고 상위 타입도 아닌 경우에 이 제네릭 타입이 타입 파라미터에 대한 무공변 이라고 한다.
- 자바에서는 모든 클래스가 무공변이다.

### 🔖 11.3.3 공변성은 하위 타입 관계를 유지한다.

- 공변적인 클래스는 제네릭 클래스에 대해 A가 B의 하위 타입일 때 하위 타입인 경우를 말한다.
- 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 앞에 out 을 넣어야 한다.

```kotlin
interface Producer<out T> {
    fun produce(): T
}
```

- 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인장의 타입이 정확히 일치하지 않더라도
  그 클래스의 인스턴스를 함수 인자나 반환값으로 사용할 수 있다.
- 모든 클래스를 공볁거으로 만들수는 없다.
    - 공변적으로 만들면 안전하지 못한 클래스도 있기 때문이다.
    - 타입 안전성을 보장 하기 위해 공변적 파라미터는 항상 아웃 위치에만 있어야 한다.
- 타입 파라미터T에 붙은 out키워드
    - 하위 타입 관계가 유지된다.
    - T를 아웃 위치에서만 사용할 수 있다.
- 변성
    - 코트에서 위험할 여지가 있는 메서드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는
      역할을 한다.
    - 생성자는 나중에 호출할 수 있는 메서드가 아닌다. 따라서 생성자는 위험할 여지가 없다.
- 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다.

### 🔖 11.3.4 반공변성은 하위 타입 관계를 뒤집는다.

- 반공변성은 공변성을 거울에 비친 상이라 할수 있다.
- 반공변 클래스의 하위 타입관계는 그 클래스의 타입 파라미터의 상하위 타입 관계와 반대다.
- 어떤 클래스에 대해 타입 B가 타입 A의 하위타입일때 Consumer<A> 가 Consumer<B> 의 하위 타입인 관계가 성립하면 제네릭 클래스는
  타입 인자T에 대해 반공변이다.
- 공변성
    - 타입 인자의 하위 타입관계가 제네릭 타입에서도 유지된다.
    - T를 아웃 위치에서만 사용할 수 있다.
- 반공변성
    - 타입 인자의 하위 타입 관계가 제네릭 타입에서만 뒤집힌다.
    - T를 인 위치에서만 사용할 수 있다.
- 무공변성
    - 하위 타입 관계가 성립하지 않는다.
    - T를 아무 위치에서나 사용할수 있다.

### 🔖 11.3.5 사용 지점 변성을 사용해 타입이 언급되는 지점에서 변성 지정

- 선언 지점 변성
    - 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치므로 편리하다.
- 사용 지점 변성
    - 타입 파라미터가 있는 타입을 사용할 때마다 그 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치 할수있는지 명시
- 함수 구현이 아웃 위치에 있는 타입 파라미터를 사용하는 메서드만 호출한다면 함수를 정의할때 그 정보를 바탕으로 타입 파라미터에 변성 변경자를 추가 가능

```kotlin
fun <T> copyData(source: MutableList<T>, destination: MutableList<T>) {
    for (item in source) {
        destination.add(item)
    }
}
```

- 타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에나 변성 변경자를 붙일수 있다.
- 따라서 파라미터 타입, 로컬 변수 타입, 함수 반환 타입 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일수 있다.
- 이때 타입 프로젝션이 일어난다.

### 🔖 11.3.6 스타 프로젝션: 제네릭 타입 인자에 대한 정보가 없음을 표현하고자 * 사용

- 타입 검사와 캐스트에 대해 설명할 때 제네릭 타입 인자 정보가 없음을 표현하고자 스타 프로젝션을 사용한다고 말헀다.
- 스타 프로젝션을 쓰는 쪽에 더 간결하지만 제네릭 타입 파라미터가 어떤 타입인지 굳이 알 필요가 없을 때만 스타 프로젝션을 사용할
  수 있다.

```kotlin
import kotlin.reflect.KClass

object Validators {
    private val validators = mutableListOf<KClass<*>, FieldValidator<*>>()

    fun <T : Any> registerValidator(kClass: KClass<T>, fieldValidator: FieldValidator<T>) {
        validators[kClass] = fieldValidator
    }

    operator fun <T : Any> get(kClass: KClass<T>): FieldValidator<T> =
        validators[kClass] as? FieldValidator<T> ?: throw IllegalArgumentException("")
}

fun main() {
    Validators.registerValidator(String::class, DefaultStringValidator)
}
```

- 타입 안전성을 보장하는 API
- 안전하지 못한 모든 로직은 클래스 내부에 감춰졌다.
- 안전하지 못한 부분을 감춤으로써 이제는 외부에서 그 부분을 잘못 사용하지 않음을 보장할 수 있다.

### 🔖 11.3.7 타입 별명

- 타입 컬렉션의 목적이 무엇인지 즉시 떠올리기는 힘들고, 복잡한 제네릭 타입이나 함수형 타입을 여러 곳에서 매번 반복해 사용을 필하고 싶을때
  코틀린에서 타입 별명을 사용할 수 있게 해준다.
- 타입 별명은 기존의 타입에 대해 다른 이름을 부여한다.
- 컴파일러 관점에서 타입 별명이 새로운 제약이나 변경을 도입하지 않는다는 사실은 기억할 만한 가치가 있다.
- 컴파일을 하는 동안 타입 별명은 원래의 타입으로 치환된다.
- 따라서 타입별명이 유용한 짧은 표기를 제공하기는 하지만 타입 안전성을 전혀 추가해주지 못한다.
