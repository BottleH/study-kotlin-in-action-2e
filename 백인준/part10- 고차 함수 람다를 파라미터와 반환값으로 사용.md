# 📚 10장 고차 함수: 람다를 파라미터와 반환값으로 사용

___

## 📖 10.1 다른 함수를 인자로 받거나 반환하는 함수 정의: 고차함수

### 🔖 10.1.1 함수 타입은 람다의 파라미터 타입과 반환 타입을 지정한다.

```kotlin
val sum: (Int, Int) -> Int = { x, y -> x + y }
val action: () -> Unit = { println(42) }
var canRetrunNull: (Int, Int) -> Int? = { x, y -> null }
var funOrNull: ((Int, Int) -> Int)? = null
```

- 함수 타입을 정의하려면 함수 파라미터의 타입을 괄호 안에 넣고 그 뒤에 화살표를 추가한 다음, 함수의 반환 타입을 지정
- 변수 선언의 일부분인 함수 타입안에 파라미터 타입을 지정했기 때문에 람다 자체에서는 파라미터 타입을 굳이 지정할 필요가 없다.
- 널이 될수 있는 함수 타입변수를 정의 할수 있다.

### 🔖 10.1.2 인자로 전달 받은 함수 호출

```kotlin
fun twoAndThree(operation: (Int, Int) -> Int) {
    val result = operation(2, 3)
    println(result)
}
fun main() {
    twoAndThree { a, b -> a + b }
}
```

- 인자로 받은 함수를 호출하는 구문은 일반 함수를 호출하는 구문과 같다.
- 그 문법은 이름뒤에 괄호를 붙이고 괄호안에 원하는 인자를 콤마로 구분하는것이다.

### 🔖 10.1.3 자바에서 코틀린 함수 타입 사용

- 자바에서는 명시적으로 그 값을 반환해줘야 한다.

### 🔖 10.1.4 함수 타입의 파라미터에 대해 기본값을 지정할 수 있고, 널이 될 수도 있다.

- 널이 될수 있는 함수 타입으로 함수를 받으면 그 함수를 직접 호출할 수 없다는 점에 유의
- null 여부를 명시적으로 검사하는 것
- 안전한 호출 구문으로 널이 될수 없는 타입으로 만드는것

### 🔖 10.1.5 함수를 함수에서 반환

- 다른 함수를 반환하는 함수를 정의 하려면 함수의 반환 타입으로 함수 타입을 지정해야 한다.
- 함수를 반환하려면 return 식에 람다, 멤버 참조 함수 타입의 값을 계산하는 식등을 넣으면된다.
- 고차 함수는 코드 구조를 개선하고 중복을 없앨 때 쓸 수 있는 아주 강력한 도구이다.

### 🔖 10.1.6 람다를 활용해 중복을 줄여 코드 재사용성 높이기

```kotlin
fun List<SiteVisit>.averageDurationFor(predicate: (SiteVisit) -> Boolean) =
    filter(predicate).map(SiteVisit::duration).average()

fun main() {
    log.averageUrationFor {
        it.os in setOf(OS.ANDROID, OS.IOS)
    }
}
```

- 코드 중복을 줄일때 함수 타입이 상당히 도움이 된다.
- 코드의 일부분을 복사해 붙여넣고 싶은 경우가 있다면 그 코드를 람다로 만들면 중복을 제거할 수 있을 것이다.

___

## 📖 10.2 인라인 함수를 사용해 람다의 부가 비용 없애기

### 🔖 10.2.1 인라이닝이 작동하는 방식

- 어떤 함수를 inlin으로 선언하면 그 함수의 본문이 인라인된다. 다른말로 하면 함수를 호출하는 코드를 함수를 호출하는 바이트코드
  대신에 함수 본문을 번역한 바이트코드로 컴파일 한다는 뜻이다.
- 람다는 다른 일반적인 경우와 마찬가지로 호출된다.
- 하나의 인라인 함수를 두 곳에서 각각 다른 람다를 사용해 호출한다면 그 두 호출은 각각 따로 인라이닝된다.
- 인라인 함수의 본문 코드가 호출 지점에 복사되고 각 람다의 본문이 인라인 함수의 본문 코드에서 람다를 사용하는 위치에 복사된다.

### 🔖 10.2.2 인라인 함수의 제약

- 인라이닝을 하는 방식으로 인해 람다를 사용하는 모든 함수를 인라이닝할 수는 없다. 함수가 인라이닝될 때 그 함수에 인자로 전달된
  람다식의 본문은 결과코드에 직접 들어갈수 있다. 하지만 이렇게 람다가 본문에 직접 펼쳐지기 떄문에 함수가 파라미터로 전달받은 람다를 본문에
  사용하는 방식이 한정될 수밖에 없다.
- 인라이닝하면 안되는 람다를 파라미터로 받는다면 noinline 변경자를 파라미터 이름 앞에 붙여 인라이닝을 금지 시킬수 있다.
- 컴파일러는 모듈이나 서드파티 라이브러리 안에서 정의된 인라인 함수도 완전히 지원한다.

### 🔖 10.2.3 컬렉션 연산 인라이닝

- 코틀린이 제공하는 함수 인라이닝은 성능에 신경 쓰지 않아도 된다.
- 시퀀스에 사용된 람다는 인라이닝되지않음
- 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며, 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출하기 때문이다.
- 지연 계산을 통해 성능을 향상시키려는 이유로 모든 컬렉션 연산에 asSequence를 붙이려고 해서는 안된다.
- 시퀀스 연산에서는 람다가 인라이닝 되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나을수 있다.

### 🔖 10.2.4 언제 함수를 인라인으로 선언할지 결정

- inline 키워드를 사용해도 람다를 인자로 받는 함수만 성능이 좋아질 가능성이 높다.
- 코틀린 인라인 함수는 바이트코드에서 각 함수 호출 지점을 함수 본문으로 대치하기 때문에 코드 중복이 생긴다.
- 람다를 인자로 받는 함수를 인라이닝하면 이익이 더 많다.
    - 인라이닝을 통해 없앨 수 있는 부가 비용이 상당하다.
    - 현재의 JVM 은 함수 호출과 람다를 인라이닝해줄 정도로 똑똑하지는 못하다.
    - 인라이닝을 사용하면 일반 람다에서는 사용할 수 없는 몇가지 기능을 사용가능 (비로컬 retrun)
- inline 변경자를 함수에 붙일때는 코드 크기에 주의를 기울여야 한다.

### 🔖 10.2.5 withLock, use, useLine로 자원 관리를 위해 인라인된 람다 사용

- withLock 락에 의해 보호되는 자원을 사용
    - 동시성 프로그래밍을 다룰때 mutex 에도 같은 기능 제공
- use 함수는 닫을수 있는 자원에 대해 호출하는 확장함수
- useLines 는 File과 Path 객체에 대해 정의돼 있고, 람다가 문자열 시퀀스에 접근하게 해준다.

___

## 📖 10.3 람다에서 반환: 고차 함수에서 흐름제어

### 🔖 10.3.1 람다 안의 return문: 람다를 둘러싼 함수에서 반환

- 람다안에서 retrun 을 사용하면 ㄹ마다에서만 반환되는 것이 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환된다.
- 그렇게 자신을 둘러싸고 있는 블록보다 바깥에 있는 다른 블록을 반환하게 만드는 return 문을 비로컬 return이라 부른다.
- 코틀린은 람다를 인자로 받는 함수 안에서 쓰이는 return이 같은 의미를 유지하게 한다.
- return이 바깥쪽 함수를 반환시킬수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우뿐이다.

### 🔖 10.3.2 람다로부터 반환: 레이블을 사용한 return

- 람다식에서도 로컬 return 을 사용할 수 있다. 람다 안에서 로컬 return 은 for 루프의 break 와 비슷한 역할을 한다.
- 로컬 return 과 비로컬 return 을 구분하기 위해 레이블을 사용해야 한다.
- return 으로 실행을 끝내고 싶은 람다식 앞에 레이블을 붙이고, return 키워드 뒤에 그 레이블을 추가해야한다.
- 람다식에 레이블을 명시하면 함수 이름을 레이블로 사용할수 없다

### 🔖 10.3.3 익명 함수 : 기본적으로 로컬 return

- 람다와 익명 함수는 retrun 식을 쓸 수 있다는 점에서 차이가 있다.
- 익명 함수는 함수 이름을 생략하고 파라미터 타입을 컴파일러가 추론하게 할 수 있다
- 익명 함수 안에서 레이블이 붙지 않은 return 식은 익명 함수 자체를 반환시킬뿐 익명 함수를 둘러싼 다른 함수를 반환시키지 않는다.
- 람다식은 fun 을 사용해 정의되지 않으므로 람다 본문의 return 은 람다 밖의 함수를 반환시킨다.







